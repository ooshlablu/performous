name: Build and Release Performous

# Controls when the workflow will run
on:
  # Triggers the workflow on merges to master, all PRs, and release tags 
  push:
    branches:
      - master
      - github-actions
    tags:
      - '[0-9]+\.[0-9]+\.[0-9]+'
      - '[0-9]+\.[0-9]+\.[0-9]+-rc[0-9]+'

  # On anything pull request related
  pull_request:

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

jobs:
  # Set up a release that packages will be published to.
  create_release:
    #if: ${{ false }}
    name: Create the Beta release
    runs-on: ubuntu-latest
    # Make sure the output variable for this step is set so it
    # can be consumed by later build steps
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      html_url: ${{ steps.create_release.outputs.html_url }}
    steps:
      - name: Create the PR release
        id: create_pr_release
        if: ${{ false && github.event_name == 'pull_request' }}
        uses: actions/create-release@v1
        env:
          # This token is automatically generated with each virtual session
          # DO NOT create this in the secrets manager
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: PR-${{ github.event.pull_request.number }}-${{ github.run_number }}
          release_name: PR-${{ github.event.pull_request.number }} Artifacts
          draft: false
          prerelease: true
      - name: Create the Beta release
        id: create_beta_release
        if: ${{ false && github.event_name != 'pull_request' }}
        uses: actions/create-release@v1
        env:
          # This token is automatically generated with each virtual session
          # DO NOT create this in the secrets manager
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.tag }}-beta-${{ github.sha }}-${{ github.run_number }}
          release_name: Beta Release ${{ github.tag }}-beta-${{ github.sha }}-${{ github.run_number }}
          draft: false
          prerelease: true
      - name: Create the Main release
        id: create_release
        if: ${{ github.event_name == 'tag' }}
        uses: actions/create-release@v1
        env:
          # This token is automatically generated with each virtual session
          # DO NOT create this in the secrets manager
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.tag }}
          release_name: Release ${{ github.tag }}
          draft: true
          prerelease: false

  # Make this depend on all of the other jobs so it comes last
  # and won't update the PR with a link without artifacts
  Update_PR_With_Artifacts:
    needs:
      - test
    #if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v5
        with:
          # This snippet is public-domain, taken from
          # https://github.com/oprypin/nightly.link/blob/master/.github/workflows/pr-comment.yml
          script: |
            async function upsertComment(owner, repo, issue_number, purpose, body) {
              const {data: comments} = await github.rest.issues.listComments(
                {owner, repo, issue_number});
              const marker = `<!-- bot: ${purpose} -->`;
              body = marker + "\n" + body;
              const existing = comments.filter((c) => c.body.includes(marker));
              if (existing.length > 0) {
                const last = existing[existing.length - 1];
                core.info(`Updating comment ${last.id}`);
                await github.rest.issues.updateComment({
                  owner, repo,
                  body,
                  comment_id: last.id,
                });
              } else {
                core.info(`Creating a comment in issue / PR ${issue_number}`);
                await github.rest.issues.createComment({issue_number, body, owner, repo});
              }
            }
            const {owner, repo} = context.repo;
            const run_id = '${{github.run_id}}';
            #const pull_requests = '${{ toJSON(github.event.pull_request) }}';
            #if (!pull_requests.length) {
            #  return core.error("This workflow doesn't match any pull requests!");
            #}
            const artifacts = await github.paginate(
              github.rest.actions.listWorkflowRunArtifacts, {owner, repo, run_id});
            if (!artifacts.length) {
              return core.error(`No artifacts found`);
            }
            let body = `Download the artifacts for this pull request:\n`;
            for (const art of artifacts) {
              body += `\n* [${art.name}](https://nightly.link/${owner}/${repo}/actions/artifacts/${art.id})`;
            }
            core.info("Review thread message body:", body);
            for (const pr of pull_requests) {
              await upsertComment(owner, repo, pr.number,
                "nightly-link", body);
            }

#  PR_UPDATER:
#    needs:
#      - test
#      - create_release
#      - Linux_Packages
#      - MacOS_Packages
#      #- Windows_Packages
#    runs-on: ubuntu-latesti
#    if: ${{ github.event_name == 'pull_request' }}
#    steps:
#      - name: Update PR with Artifact URL
#        uses: peter-evans/create-or-update-comment@v1
#        with:
#          issue-number: ${{ github.event.pull_request.number }}
#          body: |
#            Artifacts produced during this build can be found at the bottom of this page https://github.com/ooshlablu/performous/actions/runs/${{ steps.create_release.outputs.html_url }}
  #Dumb test function
  test:
    runs-on: ubuntu-latest
    steps:
      - run: |
          dd if=/dev/zero of=file.gz bs=1024 count=50

      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: file.gz
          path: file.gz



  # Create the Linux Packages
  # This is done in containers provided by
  # https://github.com/performous/performous-docker since
  # github actions provides only Ubuntu
  Linux_Packages:
    if: ${{ false }}
    #if: ${{ false }}  # disable for now
    # The upload step needs the release to be created first so it
    # can access the upload_url output
    needs: create_release
    # Ubuntu required for Linux containers
    runs-on: ubuntu-latest
    container: performous/deps:${{ matrix.os }}
    strategy:
      matrix:
        os:
          - ubuntu18.04
          - ubuntu20.04
          - ubuntu22.04
          - fedora33
          - fedora34
          - fedora35
    steps:
      - name: Checkout Git
        uses: actions/checkout@v3
        with:
          submodules: recursive

      - name: Build package
        id: build_package
        run: |
          # Pull in OS variables to figure out options later
          . /etc/os-release

          ## Set up some special cmake flags for fedora
          if [ "${ID}" == "fedora" ]; then
            EXTRA_CMAKE_ARGS="-DUSE_BOOST_REGEX=1"
          fi

          ## Figure out what type of packages we need to generate
          case ${ID} in
            'fedora')
          PACKAGE_TYPE='RPM';;
            'ubuntu')
          PACKAGE_TYPE='DEB';;
            *)
          PACKAGE_TYPE='TAR';;
          esac

          # Build the Packages
          mkdir build_cmake
          cd build_cmake
          cmake ${EXTRA_CMAKE_ARGS} -DCMAKE_BUILD_TYPE=Release\
            -DENABLE_WEBSERVER=ON\
            -DCMAKE_VERBOSE_MAKEFILE=1\
            -DENABLE_WEBCAM=ON ..
          CPU_CORES=$(nproc --all)
          make -j${CPU_CORES}
          cpack -G ${PACKAGE_TYPE}
          
          # Do some mangling to make a unique name based on the OS
          # This is needed so we don't overwite in the release each time.
          # We should probably investigate what cmake can do for package output
          # to make this cleaner in the future
          WORK_DIR=$(pwd)
          PACKAGE_NAME=$(ls ${WORK_DIR}/Performous*-Linux.*)
          PACKAGE_PREFIX=$(echo ${PACKAGE_NAME} | cut -d '.' -f1)
          PACKAGE_SUFFIX=$(echo ${PACKAGE_NAME} | cut -d '.' -f2)
          mv ${PACKAGE_NAME} ${PACKAGE_PREFIX}-${ID}_${VERSION_ID}.${PACKAGE_SUFFIX}
          ARTIFACT_PATH=$(ls ${WORK_DIR}/Performous*-Linux-*.*)
          ARTIFACT_NAME=$(echo ${ARTIFACT_PATH} | rev | cut -d '/' -f1 | rev)
          echo "ARTIFACT_PATH=${ARTIFACT_PATH}" >> ${GITHUB_ENV}
          echo "ARTIFACT_NAME=${ARTIFACT_NAME}" >> ${GITHUB_ENV} 

      # Upload artifacts during each run
      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: ${{ env.ARTIFACT_PATH }}
 
      # Upload artifacts to releases only during PR events
      - name: Upload release assets
        id: upload_assets
#        if: ${{ githubi.event_name != 'pull_request' }}
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create_release.outputs.upload_url }}
          asset_path: ${{ env.ARTIFACT_PATH }}
          asset_name: ${{ env.ARTIFACT_NAME }}
          asset_content_type: application/octet-stream


  # Create the MacOS dmg
  MacOS_Packages:
    if: ${{ false }}
    #if: ${{ false }}  # disable for now
    # The upload step needs the release to be created first so it
    # can access the upload_url output
    needs: create_release
    # Ubuntu required for Linux containers
    runs-on: macos-latest
    steps:
      - name: Checkout Git
        uses: actions/checkout@v3
        with:
          submodules: recursive

      - name: Install Dependencies
        id: install_deps
        run: |
           brew install boost cmake ffmpeg@4 help2man icu4c portaudio portmidi\
             opencv libepoxy librsvg libxml++3 sdl2 dylibbundler asio fftw glm
           brew link ffmpeg@4

      - name: Build package
        id: build_package
        run: |
          cd osx-utils
          chmod +x ./performous-app-build.sh
          ./performous-app-build.sh
          echo "ARTIFACT_PATH=$(pwd)/Performous.dmg" >> ${GITHUB_ENV}

      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: Performous.dmg
          path: ${{ env.ARTIFACT_PATH }}

      - name: Upload release assets
        id: upload_assets
#        if: ${{ github.event_name != 'pull_request' }}
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create_release.outputs.upload_url }}
          asset_path: ${{ env.ARTIFACT_PATH }}
          asset_name: Performous.dmg
          asset_content_type: application/octet-stream


  Windows_Packages:
    needs: create_release
    runs-on: windows-latest
    if: ${{ false }}
    steps:
      - name: Checkout Git
        uses: actions/checkout@v3
        with:
          submodules: recursive
      
      - uses: ilammy/msvc-dev-cmd@v1.4.1

      - uses: seanmiddleditch/gha-setup-ninja@master      
    
      #- name: Extract a zip and populate cache
      #  run: |
      #     mkdir build
      #     cd build
      #     mkdir x64-debug
      #     cd x64-debug
      #     Invoke-WebRequest -OutFile vcpkg_installed.zip -Uri https://asgardsings.nl/vcpkg_installed.zip
      #     7z x vcpkg_installed.zip
      
      #- name: Cache vcpkg compiled binaries
      #  uses: actions/cache@v3
      #  env:
      #    cache-name: cache-vcpkg
      #  with:
      #    path: ./build/x64-debug/vcpkg_installed
      #    key: ${{ runner.os }}-${{ env.cache-name }}-${{ hashFiles('**/vcpkg.json') }}

      - uses: lukka/run-vcpkg@v10.2
        with:
          vcpkgGitCommitId: '71d274d7ce32d7f2508062a70e0a5ebe981319eb'

      - uses: lukka/run-cmake@v10
        continue-on-error: true
        with:
          configurePreset: 'x64-debug'
          buildPreset: 'x64-debug'



      #- name: Restore dependencies
      #  id: restore_dependencies-x64
      #  continue-on-error: true
      #  #env:
      #    #VCPKG_FEATURE_FLAGS: binarycaching,versions
      #    #VCPKG_BINARY_SOURCES: 'files,D:/a/performous/performous/build/x64-debug/vcpkg_installed,readwrite'
      #  run: |
      #     mkdir build
      #     cd build
      #     mkdir x64-debug
      #     cmake .. -G Ninja --preset x64-debug 
      #
      #- name: Build Performous
      #  id: build_performous_x64
      #  run: |
      #     cmake --build x64-debug
      #     
      #- name: Create Installer
      #  id: package_performous_x64
      #  run: |
      #     cd x64-debug
      #     cpack -G NSIS x64-release
      #     set ARTIFACT_PATH="${CPACK_BUILD_SOURCE_DIRS}/${CPACK_PACKAGE_FILE_NAME}.exe" >> ${GITHUB_ENV}
      #     set ARTIFACT_FILENAME="${CPACK_PACKAGE_NAME}-${CPACK_PACKAGE_VERSION}.exe" >> ${GITHUB_ENV}
      #
      #- name: Upload release assets
      #  id: upload_assets
      #  uses: actions/upload-release-asset@v1
      #  env:
      #    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #  with:
      #    upload_url: ${{ needs.create_release.outputs.upload_url }}
      #    asset_path: ${{ env.ARTIFACT_PATH }}
      #    asset_name: ${{ env.ARTIFACT_FILENAME }}
      #    asset_content_type: application/octet-stream
